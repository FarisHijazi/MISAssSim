# -*- coding: utf-8 -*-
"""COE403-Assembler.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ry1iqMchHlX9o7sXect9mdND02Pp9E8I
"""

from tkinter import *
import re

# from tkFileDialog import *
from tkinter import filedialog
import os.path
from argparse import ArgumentParser
import sys
from tkinter.filedialog import askopenfilename, asksaveasfilename

filename = "Untitled"
fileexists = False
symbolTable = {}
global currentLine


def asmtointsection2(args, opcode, ra, rb, imm):
    # Compare with Zero Branches (Pseudo)
    if args[0] in opcodes.get('bzero'):
        ra = reg(args[1])
        imm = 0

        if args[0] == "blez" or args[0] == "bgtz":
            imm = 1
        return ra, rb, imm
    # Pseudo-Branches
    if args[0] in {'ble': 10, 'bgt': 11, 'bleu': 13, 'bgtu': 12, }:
        ra = reg(args[1])
        imm = int(args[2]) + 1
        return ra, rb, imm
    # Ret
    # Register-immediate Branches
    if 8 <= opcode <= 13:
        ra = reg(args[1])
        imm = int(args[2])  # p15 states this should be Uimm5
    # Register-Register Branch
    elif 16 <= opcode <= 21:
        ra = reg(args[1])
        rb = reg(args[2])
        # loop or loopd or jalr
    elif opcode == 22 or opcode == 22 or opcode == 15:
        rb = reg(args[1])
        ra = reg(args[2])
    elif opcode == 14:
        ra = reg(args[1])
    return ra, rb, imm


def asmtoint3(args, opcode):
    func = opcodes.get('ls').get(args[0])[1]
    print(str(func))
    rc = 0
    rd = 0
    imm = 0
    s = 0
    # Load I-Format
    if opcode == 24:
        rb = reg(args[1])
        ra = reg(args[2])
        imm = int(args[3])
    # Store I-Format
    elif opcode == 25:
        rb = reg(args[3])
        ra = reg(args[1])
        imm = int(args[2])
    # Loadx R-Format
    elif opcode == 26:
        rb = reg(args[3])
        ra = reg(args[2])
        rd = reg(args[1])
        s = int(args[4])
    elif opcode == 27:
        rb = reg(args[2])
        ra = reg(args[1])
        rc = reg(args[4])
        s = int(args[3])
    return ra, rb, rc, rd, s, func, imm
#######################################################################################3

def asmtointALUI(args,opcode, ra, rb, rc, rd, func, imm, p):
    rb  = int(args[1][1:])
    ra  = int(args[2][1:])

    opcode, func, imm = sec4_ALUI_dict[args[0]]
	return opcode, ra, rb, func, imm


def asmtointRET(args):  
    ra     = int(args[1][1:])
    rb     = int(args[2][1:])
	opcode = 36

    func, imm = sec4_RET_dict[args[0]]

	return opcode, ra, rb, func, imm	



def asmtointSHIFT(args):
    rb     = int(args[1][1:])
    ra     = int(args[2][1:])
	opcode = 37

    func, imm_L, imm_R, imm = sec4_RET_dict[args[0]] 
    # imm_R has the same postion as p
    
	return opcode, ra, rb, func, imm_L, imm_R, imm		

def asmtointALU(args):
    rd     = int(args[1][1:])
	ra     = int(args[2][1:])
    rb     = int(args[3][1:])
	opcode = 40
    
    func, x, n, swab = sec4_ALU_dict[args[0]]
    
    if swab:
        ra, rb = rb, ra
        
    return opcode, ra, rb, func, n, x, rd    



def asmtointFPU1(args):
    rd = reg(args[1])
    ra = reg(args[2])
    opcode = 42
    p, func = fpu1_dict[args[0]]
    return opcode, ra,rd, func, p


def asmtointFPU2(args):
    rd = reg(args[1])
    ra = reg(args[2])
    rb = reg(args[3])
    opcode = 43
    p, func, swp = fpu2_dict[args[0]]

    if swp:
        ra, rb = rb, ra

    return opcode, ra, rb, rd, func, p

def asmtointFPU3(args):
    rd = reg(args[1])
    ra = reg(args[2])
    rb = reg(args[3])
    rc = reg(args[4])
    opcode = 44
    if(args[0]=="min.d" or args[0]=="max.d"):
        opcode = 43
    p, func, swp = fpu3_dict[args[0]]

    if swp:
        rc, rb = rb, rc

    return opcode, ra, rb, rc, rd, func, p


def asmtoint5(args):
    print("asmtoint5")
    rd = reg(args[1])
    ra = reg(args[2])
    rb = reg(args[3])
    rc = reg(args[4])
    opcode = 41

    x, func = sec5_dict[args[0]]

    if args[0] == "selz":  # sel , switch b and c
        temp = rb
        rb = rc
        rc = temp

    return opcode, ra, rb, rc, rd, func, x


def inttohex(opcode, ra, rb, rc, rd, func, imm, p, offset, s, x):
    if opcode == 2 or opcode == 3:
        opstr = format(opcode, '06b')
        offsetstr = format(offset, '026b')
        instruction = opstr + offsetstr
    # Section 2 (branch imm)
    elif 8 <= opcode <= 13:
        opstr = format(opcode, '06b')
        rastr = format(ra, '05b')
        immstr = format(imm, '05b')  # p15 states this should be Uimm5 is this the correct format???
        offsetstr = format(offset, '016b')
        instruction = opstr + rastr + immstr + offsetstr
    # JR instruction p15
    elif opcode == 14:
        opstr = format(opcode, '06b')
        rastr = format(ra, '05b')
        emptystr = format(0, '05b')
        offsetstr = format(offset, '016b')
        instruction = opstr + rastr + emptystr + offsetstr
    # Section2 (non imm branch)
    elif 15 <= opcode <= 23:
        opstr = format(opcode, '06b')
        rastr = format(ra, '05b')
        rbstr = format(rb, '05b')
        offsetstr = format(offset, '016b')
        instruction = opstr + rastr + rbstr + offsetstr
        # Section 3
    elif opcode == 24 or opcode == 25:
        opstr = format(opcode, '06b')
        rastr = format(ra, '05b')
        rbstr = format(rb, '05b')
        funcstr = format(func, '04b')
        immstr = format(imm, '012b')
        instruction = opstr + rastr + rbstr + funcstr + immstr
    elif opcode == 26 or opcode == 27:
        opstr = format(opcode, '06b')
        rastr = format(ra, '05b')
        rbstr = format(rb, '05b')
        funcstr = format(func, '04b')
        sstr = format(s, '02b')
        rcstr = format(rc, '05b')
        rdstr = format(rd, '05b')
        instruction = opstr + rastr + rbstr + funcstr + sstr + rcstr + rdstr
    elif opcode == 32 or opcode == 33 or opcode == 34
         	 or opcode == 35 or opcode == 36 :
        opstr = format(opcode, '06b')
        rastr = format(ra,     '05b')
        rbstr = format(rb,     '05b')
		fnstr = format(func,   '04b')
        imstr = format(imm,    '12b')
        instruction = opstr + rastr + rbstr + fnstr + imstr
    elif (opcode == 37):
        opstr  = format(opcode,   '06b')
        rastr  = format(ra,       '05b')
        rbstr  = format(rb,       '05b')
		fnstr  = format(func,     '04b')
        imLstr = format(imm_L,    '06b')
        imRstr = format(imm_R,    '06b')
        imstr  = format(imm,      '12b')
        if   imm_L == X and imm_R == X and imm <> X
          instruction = opstr + rastr + rbstr + fnstr + imstr
        elif imm_L <> X and imm_R <> X and imm == X
          instruction = opstr + rastr + rbstr + fnstr + imLstr + imRstr
        elif imm_L <> X and imm_R == X and imm == X
          instruction = opstr + rastr + rbstr + fnstr + imLstr 
        elif imm_L == X and imm_R <> X and imm == X
          instruction = opstr + rastr + rbstr + fnstr + imRstr 
	elif (opcode == 40):
        opstr = format(opcode, '06b')
        rastr = format(ra,     '05b')
        rbstr = format(rb,     '05b')
		fnstr = format(func,   '04b')
		x_str = format(x,      '02b')
        n_str = format(n,      '04b')
        rdstr = format(imm,    '05b')
        if   x == 0 or x == 1
        instruction = opstr + rastr + rbstr + fnstr + x_str + rdstr
        elif x == 2 or x == 3
        instruction = opstr + rastr + rbstr + n_str + x_str + rdstr
    elif opcode == 41:
        opstr = format(opcode, '06b')
        rastr = format(ra, '05b')
        rbstr = format(rb, '05b')
        funcstr = format(func, '04b')
        xstr = format(s, '02b')
        rcstr = format(rc, '05b')
        rdstr = format(rd, '05b')
        instruction = opstr + rastr + rbstr + funcstr + xstr + rcstr + rdstr
        # FPU instructions
    elif opcode == 42 or opcode == 43 or opcode == 44:
        opstr = format(opcode, '06b')
        rastr = format(ra, '05b')
        rbstr = format(rb, '05b')
        rcstr = format(rc, '05b')
        rdstr = format(rd, '05b')
        fnstr = format(func, '05b')
        pstr = format(p, '01b')
        instruction = opstr + rastr + rbstr + fnstr + pstr + rcstr + rdstr
    else:
        opstr = format(opcode, '02b')
        rbstr = format(rb, '03b')
        rastr = format(ra, '03b')
        if imm < 0:
            imm2s = ((-imm) ^ 255) + 1
            immstr = format(imm2s, '08b')
        else:
            immstr = format(imm, '08b')
        # print opstr, rtstr, rsstr, immstr
        instruction = opstr + rastr + rbstr + immstr
    return format(int(instruction, 2), '04x')


"""
layed out according to section/format (I'm not sure either)
"""
opcodes = {
    'j': {
        'j': 2,
        'jal': 3,
        'jr': 14,
        'ret': 14,
        'jalr': 15,
    },
    'b': {
        'beqi': 8,
        'bnei': 9,
        'blti': 10,
        'bgei': 11,
        'bltui': 12,
        'bgeui': 13,

        'beq': 16,
        'bne': 17,
        'blt': 18,
        'bge': 19,
        'bltu': 20,
        'bgeu': 21,

        # Compare with immediate (0 to 30) and Branch Pseudo Instructions :
        'ble': 10,
        'bgt': 11,
        'bleu': 13,
        'bgtu': 12,
        # -----------
        'loop': 22,
        'loopd': 23
    },

    'bzero': {
        # Compare with Zero and Branch Pseudo-Instructions (use immediate instructions) :
        'beqz': 8,
        'bnez': 9,
        'bltz': 10,
        'bgtz': 11,
        'bgez': 11,
        'blez': 10
    },

    'ls': {
        # All instructions below come in I-Format or R-Format
        'lb': (24, 4),
        'lh': (24, 5),
        'lw': (24, 6),
        'ld': (24, 7),

        'lbu': (24, 0),
        'lhu': (24, 1),
        'lwu': (24, 2),
        'ldu': (24, 3),

        'sb': (25, 0),
        'sh': (25, 1),
        'sw': (25, 2),
        'sd': (25, 3)
    },
    'alu': {  # ALU instructions (section 5)
        "add": 41,
        "and": 41,
        "or": 41,
        "xor": 41,
        "nadd": 41,
        "cand": 41,
        "cor": 41,
        "xnor": 41,
        "andeq": 41,
        "andne": 41,
        "andlt": 41,
        "andge": 41,
        "andltu": 41,
        "andgeu": 41,
        "oreq": 41,
        "orne": 41,
        "orlt": 41,
        "orge": 41,
        "orltu": 41,
        "orgeu": 41,
        "min": 41,
        "max": 41,
        "minu": 41,
        "maxu": 41,
        "andgt": 41,
        "andle": 41,
        "andgtu": 41,
        "andleu": 41,
        "orgt": 41,
        "orle": 41,
        "orgtu": 41,
        "orleu": 41,
        "sel": 41,
        "seln": 41,
        "selp": 41,
        "selz": 41,
        "madd": 41,
        "nmadd": 41
    },
    'fpu2': {
        "eq.s": -1,
        "eq.d": -1,
        "ne.s": -1,
        "ne.d": -1,
        "lt.s": -1,
        "lt.d": -1,
        "ge.s": -1,
        "ge.d": -1,
        "inf.s": -1,
        "inf.d": -1,
        "nan.s": -1,
        "nan.d": -1,
        "mul.s": -1,
        "mul.d": -1,
        "div.s": -1,
        "div.d": -1,
        "gt.s": -1,
        "gt.d": -1,
        "le.s": -1,
        "le.d": -1,
        "sub.s": -1,
        "sub.d": -1,
    }
}

# opcode, func, imm
sec4_RET_dict = {
    "retadd" :  (0,  0, int(args[3]) ),
    "retnadd":  (1,  0, int(args[3]) ),
    "retand" :  (2,  1, int(args[3]) ),
    "retcand":  (3,  1, int(args[3]) ),
    "retor"  :  (4,  2, int(args[3]) ),
    "retcor" :  (5,  2, int(args[3]) ),
    "retxor" :  (6,  4, int(args[3]) ),
    "retset" :  (7,  4, int(args[2]) ),
    "reteq"  :  (8,  5, int(args[3]) ),
    "retne"  :  (9,  5, int(args[3]) ),
    "retlt"  :  (10, 6, int(args[3]) ),
    "retge"  :  (11, 6, int(args[3]) ),
    "retltu" :  (12, 7, int(args[3]) ),
    "retgeu" :  (13, 7, int(args[3]) ),
    "retmin" :  (14, 7, int(args[3]) ),
    "retmax" :  (15, 7, int(args[3]) ),		
}

# opcode, func, imm
sec4_ALUI_dict = {
    "add" :  (32,   0, int(  args[3])),
    "nadd":  (32,   1, int(  args[3])),
    "and" :  (32,   2, int(  args[3])),
    "cand":  (32,   3, int(  args[3])),
    "or"  :  (33,   4, int(  args[3])),
    "cor" :  (33,   5, int(  args[3])),
    "xor" :  (33,   6, int(  args[3])),
    "set" :  (33,   7, int(  args[2])),
    "eq"  :  (34,   8, int(  args[3])),
    "ne"  :  (34,   9, int(  args[3])),
    "lt"  :  (34,  10, int(  args[3])),
    "ge"  :  (34,  11, int(  args[3])),
    "ltu" :  (35,  12, int(  args[3])),
    "geu" :  (35,  13, int(  args[3])),
    "min" :  (35,  14, int(  args[3])),
    "max" :  (35,  15, int(  args[3])),
	"sub" :  (32,   0, int( -args[3])),
    "andc":  (32,   0, int( -args[3])),
    "orc" :  (33,   4, int( -args[3])),
    "xnor":  (33,   6, int( -args[3])),
    "mov" :  (33,   4,              0),
    "neg" :  (32,   1,              0),
    "not" :  (33,   5,              0),
    "gt"  :  (32,   0, int(1+args[3])),
    "le"  :  (32,   0, int(1+args[3])),
	"gtu" :  (33,   4, int(1+args[3])),
    "leu" :  (33,   4, int(1+args[3])),
}     

# func, imm_L, (imm_R  OR  p), imm
sec4_SHIFT_dict = {
    "shlr" :  ( 0,  int(args[3]),  int(args[4]),              X),
    "shlr" :  ( 1,  int(args[3]),  int(args[4]),              X),
    "salr" :  ( 2,  int(args[3]),  int(args[4]),              X),
    "ror"  :  ( 3,             X,  int(args[3]),              X),
    "mul"  :  ( 8,             X,             X,   int(args[3])),
    "div"  :  (12,             X,             X,   int(args[3])),
    "mod"  :  (13,             X,             X,   int(args[3])),
    "divu" :  (14,             X,             X,   int(args[3])),
    "modu" :  (15,             X,             X,   int(args[3])),
    "shl"  :  ( 0,  int(args[3]),             X,              X),
    "shr"  :  ( 0,             X,  int(args[3]),              X),
    "sar"  :  ( 2,             X,  int(args[3]),              X),
    "rol"  :  ( 3,             X,  int(args[3]),              X),
    "extr" :  ( 2,  int(args[3]),  int(args[4]),              X),
    "extru":  ( 0,  int(args[3]),  int(args[4]),              X),
    "ext"  :  ( 2,  int(args[3]),             X,              X),
	"extu" :  ( 0,  int(args[3]),             X,              X),
    "insz" :  ( 2,  int(args[3]),  int(args[4]),              X),

} 

# func, x, n, swap
sec4_ALU_dict = {
    "add"  :  ( 0,  0,                -1,  false),
    "nadd" :  ( 1,  0,                -1,  false),
    "and"  :  ( 2,  0,                -1,  false),
    "cand" :  ( 3,  0,                -1,  false),
    "or"   :  ( 4,  0,                -1,  false),
    "cor"  :  ( 5,  0,                -1,  false),
    "xor"  :  ( 6,  0,                -1,  false),
    "xnor" :  ( 7,  0,                -1,  false),
    "eq"   :  ( 8,  0,                -1,  false),
    "ne"   :  ( 9,  0,                -1,  false),
    "lt"   :  (10,  0,                -1,  false),
    "ge"   :  (11,  0,                -1,  false),
    "ltu"  :  (12,  0,                -1,  false),
    "geu"  :  (13,  0,                -1,  false),
    "min"  :  (14,  0,                -1,  false),
    "max"  :  (15,  0,                -1,  false),
	"shl"  :  ( 0,  0,                -1,  false),
    "shr"  :  ( 1,  1,                -1,  false),
	"sar"  :  ( 2,  1,                -1,  false),
    "ror"  :  ( 3,  1,                -1,  false),
    "mul"  :  ( 8,  1,                -1,  false),
    "div"  :  (12,  1,                -1,  false),
    "mod"  :  (13,  1,                -1,  false),
	"divu" :  (14,  1,                -1,  false),
    "modu" :  (15,  1,                -1,  false),
	"adds" :  (-1,  2,  int(args[4][1:]),  false),
	"nadds":  (-1,  3,  int(args[4][1:]),  false),
    "sub"  :  ( 1,  0,                -1,  true ),
	"andc" :  ( 1,  0,                -1,  true ),
	"orc"  :  ( 1,  0,                -1,  true ),
    "gt"   :  ( 1,  0,                -1,  true ),
    "le"   :  ( 1,  0,                -1,  true ),
    "gtu"  :  ( 1,  0,                -1,  true ),                
	"leu"  :  ( 1,  0,                -1,  true ),		
}

fpu1_dict = {
    "abs.s": (0, 0),
    "abs.d": (1, 0),
    "neg.s": (0, 1),
    "neg.d": (1, 1),
    "sqrt.s": (0, 2),
    "sqrt.d": (1, 2),
    "cvts.d": (0, 4),
    "cvtd.s": (1, 4),
    "cvts.i": (0, 5),
    "cvtd.i": (1, 5),
    "cvti.s": (0, 6),
    "cvti.d": (1, 6),
    "rint.s": (0, 7),
    "rint.d": (1, 7),
}
# neumonic: (p, func, swap_ra_rb)
fpu2_dict = {
    "eq.s": (0, 0, False),
    "eq.d": (1, 0, False),
    "ne.s": (0, 1, False),
    "ne.d": (1, 1, False),
    "lt.s": (0, 2, False),
    "lt.d": (1, 2, False),
    "ge.s": (0, 3, False),
    "ge.d": (1, 3, False),
    "inf.s": (0, 4, False),
    "inf.d": (1, 4, False),
    "nan.s": (0, 5, False),
    "nan.d": (1, 5, False),

    "add.s": (0, 8, False),
    "add.d": (1, 8, False),
    "nadd.s": (0, 9, False),
    "nadd.d": (1, 9, False),
    "mul.s": (0, 10, False),
    "mul.d": (1, 10, False),
    "div.s": (0, 11, False),
    "div.d": (1, 11, False),
    "min.s": (0, 12, False),
    "min.d": (1, 12, False),
    "max.s": (0, 13, False),
    "max.d": (1, 13, False),

    "gt.s": (0, 2, True),
    "gt.d": (1, 2, True),
    "le.s": (0, 3, True),
    "le.d": (1, 3, True),
    "sub.s": (0, 9, True),
    "sub.d": (1, 9, True),
}
# neumonic: (p, func, swap_rc_rb)
fpu3_dict = {
    "add.s": (0, 8, False),
    "add.d": (1, 8, False),
    "nadd.s": (0, 9, False),
    "nadd.d": (1, 9, False),
    "madd.s": (0, 10, False),
    "madd.d": (1, 10, False),
    "nmadd.s": (0, 11, False),
    "nmadd.d": (1, 11, False),
    "min.s": (0, 12, False),
    "min.d": (1, 12, False),
    "max.s": (0, 13, False),
    "max.d": (1, 13, False),
    "andeq.s": (0, 0, False),
    "andeq.d": (1, 0, False),
    "andne.s": (0, 1, False),
    "andne.d": (1, 1, False),
    "andlt.s": (0, 2, False),
    "andlt.d": (1, 2, False),
    "andge.s": (0, 3, False),
    "andge.d": (1, 3, False),
    "oreq.s": (0, 4, False),
    "oreq.d": (1, 4, False),
    "orne.s": (0, 5, False),
    "orne.d": (1, 5, False),
    "orlt.s": (0, 6, False),
    "orlt.d": (1, 6, False),
    "orge.s": (0, 7, False),
    "orge.d": (1, 7, False),
    "andgt.s": (0, 2, True),
    "andgt.d": (1, 2, True),
    "andle.s": (0, 3, True),
    "andle.d": (1, 3, True),
    "orgt.s": (0, 6, True),
    "orgt.d": (1, 6, True),
    "orle.s": (0, 7, True),
    "orle.d": (1, 7, True),
}
# key: neumonic, value: (x, func)
sec5_dict = {
    "add": (0, 0),
    "and": (0, 2),
    "or": (0, 4),
    "xor": (0, 6),
    "nadd": (0, 1),
    "cand": (0, 3),
    "cor": (0, 5),
    "xnor": (0, 7),
    "andeq": (1, 0),
    "andne": (1, 1),
    "andlt": (1, 2),
    "andge": (1, 3),
    "andltu": (1, 4),
    "andgeu": (1, 5),
    "oreq": (1, 8),
    "orne": (1, 9),
    "orlt": (1, 10),
    "orge": (1, 11),
    "orltu": (1, 12),
    "orgeu": (1, 13),
    "min": (1, 14),
    "max": (1, 15),
    "minu": (1, 6),
    "maxu": (1, 7),
    "andgt": (1, 2),
    "andle": (1, 3),
    "andgtu": (1, 4),
    "andleu": (1, 5),
    "orgt": (1, 10),
    "orle": (1, 11),
    "orgtu": (1, 12),
    "orleu": (1, 13),
    "sel": (2, 0),
    "seln": (2, 1),
    "selp": (2, 2),
    "selz": (2, 0),
    "madd": (2, 4),
    "nmadd": (2, 5)
}
ret_dict = {
    "retadd": 0,
    "retnadd": 1,
    "retand": 2,
    "retcand": 3,
    "retor": 4,
    "retcor": 5,
    "retxor": 6,
    "retset": 7,
    "reteq": 8,
    "retne": 9,
    "retlt": 0,
    "retge": 1,
    "retltu": 2,
    "retgeu": 3,
    "retmin": 4,
    "retmax": 5,
}


def asmtointNOP(args, opcode, ra, rb, rc, rd, func, imm, p):
    # FIXME: this is a fake function
    return opcode, imm


def asmtoint(asm):
    regex = re.compile(r"[,\s()=\[|\]]+")
    asm_split = re.split(regex, asm)
    args = []
    for i in range(len(asm_split)):
        if asm_split[i] != "":
            args.append(asm_split[i])

    print("asm_split", asm_split)

    for x in asm_split:
        if re.search(r'[^\w\d.\-]', x):
            raise Exception('Invalid character encountered:', asm)

    # print args
    opcode = 0
    func = 0
    rd = 0
    ra = 0
    rb = 0
    rc = 0
    imm = 0
    p = 0
    x = 0
    s = 0
    offset = 0

    # Section 6 FPU1
    if args[0] in fpu1_dict:
        if len(args) != 3:
            raise Exception('Incorrect Number of arguments')
        opcode, ra, rd, func, p = asmtointFPU1(args)
    # Section 6 FPU2
    elif args[0] in fpu2_dict:
        # Check if common between fpu2 and fpu3
        if args[0] in fpu3_dict:
            if len(args) == 4:
                opcode, ra, rb, rd, func, p = asmtointFPU2(args)
            elif len(args) == 5:
                opcode, ra, rb, rc, rd, func, p = asmtointFPU3(args)
            else:
                raise Exception('Incorrect Number of arguments'+ str(len(args)))
        elif len(args) != 4:
            raise Exception('Incorrect Number of arguments')
        opcode, ra, rb, rd, func, p = asmtointFPU2(args)
    # Section 6 FPU3    
    elif args[0] in fpu3_dict:
        if len(args) != 5:
            raise Exception(
                'Incorrect Number of arguments : ' + str(len(args)))
        opcode, ra, rb, rc, rd, func, p = asmtointFPU3(args)


    # SECTION 2 branches
    elif args[0] in opcodes.get('b'):
        if len(args) != 4:
            raise Exception('Incorrect Number of arguments : ' + str(len(args)))
        # Check if user used immediate or register version of the instruction
        if args[2][0] != "r":
            args[0] = args[0] + "i"

        opcode = opcodes.get('b').get(args[0])
        label = args[3]
        offset = symbolTable[label] - currentLine
        ra, rb, imm = asmtointsection2(args, opcode, ra, rb, imm)
    elif args[0] in opcodes.get('bzero'):
        if len(args) != 3:
            raise Exception('Incorrect Number of arguments : ' + str(len(args)))

        opcode = opcodes.get('b').get(args[0])
        label = args[2]
        offset = symbolTable[label] - currentLine
        ra, rb, imm = asmtointsection2(args, opcode, ra, rb, imm)
    # SECTION 2 j type (does not call asmtointsection2)
    elif args[0] in opcodes.get('j'):
        if args[0] == "jal" or args[0] == "j":
            label = args[1]
            offset = symbolTable[label] - currentLine
        elif args[0] == "jr":
            if len(args) == 3:
                label = args[2]
                offset = symbolTable[label] - currentLine
            elif len(args) == 2:
                offset = 0
            else:
                raise Exception(
                    'Incorrect Number of arguments : ' + str(len(args)))
            ra = int(args[1])
        elif args[0] == "jalr":
            if len(args) == 4:
                label = args[3]
                offset = symbolTable[label] - currentLine
            elif len(args) == 3:
                offset = 0
            else:
                raise Exception(
                    'Incorrect Number of arguments : ' + str(len(args)))
            ra = reg(args[2])
            rb = reg(args[1])
        elif args[0] == "ret":
            if len(args) != 1:
                raise Exception(
                    'Incorrect Number of arguments : ' + str(len(args)))
            offset = 0
            ra = 31
        opcode = opcodes.get('j').get(args[0])
    # Section 3
    elif args[0] in opcodes.get('ls'):
        opcode = opcodes.get('ls').get(args[0])[0]
        # Check if it is R-Format (has 5 arguments)
        if len(args) == 5:
            opcode = opcode + 2
        if len(args) != 5 and len(args) != 4:
            raise Exception(
                'Incorrect Number of arguments : ' + str(len(args)))
        ra, rb, rc, rd, s, func, imm = asmtoint3(args, opcode)


    # Section 4
    # Checking if it belongs to ALUI (Opcode 32 - 35)

    elif args[0] in ["add", "and", "or", "xor", "nadd", "cand", ]:
        if len(args) != 5:
            opcode, ra, rb, func, imm = asmtointALUI(args, opcode, ra, rb, rc, rd, func, imm, p)

    # Checking if it belongs to RET (Opcode 36)
    elif args[0] in ["cor", "xnor", "sub", "andc", ]:
        print(args[0])
        if (len(args) != 4) and args[0]!= "xnor" and args[0]!="cor":# XNOR is in section 5 and contains 5 arguments
             raise Exception('Incorrect Number of arguments')
        if len(args) == 4: # This line exists to not include section5 xnor
            opcode, ra, rb, func, imm = asmtointRET(args, opcode, ra, rb, rc, rd, func, imm, p)
    # Checking if it belongs to NOP (Opcode 0)         ############## REVIEW, I have done nothing with this NOP
    elif args[0] == "orc":
        if len(args) != 2:
            raise Exception('Incorrect Number of arguments')
        opcode, imm = asmtointNOP(args, opcode, ra, rb, rc, rd, func, imm, p)

    # Checking if it belongs to SHIFT (Opcode 37)
    elif args[0] in ["eq", "ne", "lt", "ge", "ltu", ]:
        if len(args) != 4:
            raise Exception('Incorrect Number of arguments')
        opcode, ra, rb, func, imm, p = asmtointSHIFT(args, opcode, ra, rb, rc, rd, func, imm, p)

    # Checking if it belongs to ALU (Opcode 40)
    elif args[0] in ["geu", "min", "max", "gt", "le", "gtu", "leu", "retadd", "retnadd", "retand", "retcand", ]:
        if len(args) != 4 and args[0]!= "min" and args[0]!="max":  # WHY does it have to be length 4 when adds and nadds has a length of 3?!!!
            raise Exception('Incorrect Number of arguments')
        opcode, ra, rb, func, x, rd = asmtointALU(args, opcode)
    # Section 5 Opcode 41
    elif args[0] in opcodes.get('alu'):
        if len(args) != 5 and len(args)!=4:
            raise Exception("Incorrect Number of parameters passed")
        if len(args)==5:
            opcode, ra, rb, rc, rd, func, x = asmtoint5(args)
    else:
        print("Returning all zeroes since the instruction is not recognized")
        return 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

    # opcode 41
    # This is not elif statement because it shares instruction names with previous elif statements
    if args[0] in opcodes.get('alu'):
        if len(args) != 5 and len(args)!=4:
            raise Exception("Incorrect Number of parameters passed")
        if len(args)==5:
            opcode, ra, rb, rc, rd, func, x = asmtoint5(args)
    return opcode, ra, rb, rc, rd, func, imm, p, offset, s, x


def asmtointALU(args, opcode):
    """
    Note that func and n both share the same variable func
    :param args:
    :param opcode:
    :return: (opcode, ra, rb, func, x, rd)
    """
    rd = reg(args[1])
    ra = reg(args[2])
    rb = reg(args[3])
    opcode = 40

    # (func, x, n)
    opcode40_dict = {
        "add": (0, 0),
        "nadd": (1, 0),
        "and": (2, 0),
        "cand": (3, 0),
        "or": (4, 0),
        "cor": (5, 0),
        "xor": (6, 0),
        "xnor": (7, 0),
        "eq": (8, 0),
        "ne": (9, 0),
        "lt": (10, 0),
        "ge": (11, 0),
        "ltu": (12, 0),
        "geu": (13, 0),
        "min": (14, 0),
        "max": (15, 0),
        "shl": (0, 1),
        "shr": (1, 1),
        "sar": (2, 1),
        "ror": (3, 1),
        "mul": (8, 1),
        "div": (12, 1),
        "mod": (13, 1),
        "divu": (14, 1),
        "modu": (15, 1),

        "adds": ("n", 2),  # n = 0 ~ 15
        "nadds": ("n", 2),  # n = 0 ~ 15

        "sub": (1, 0),  # uses nadd, swaps ra & rb
        "andc": (1, 0),  # uses cand, swaps ra & rb
        "orc": (1, 0),  # uses cor,  swaps ra & rb
        "gt": (1, 0),  # uses lt,   swaps ra & rb
        "le": (1, 0),  # uses ge,   swaps ra & rb
        "gtu": (1, 0),  # uses ltu,  swaps ra & rb
        "leu": (1, 0),  # uses geu,  swaps ra & rb
    }

    func, x = opcode40_dict.get(args[0])
    if func == "n":
        func = int(args[2])

    # Pseudo-Instructions for ALU
    if args[0] in ["sub", "andc", "orc", "gt", "le", "gtu", "leu"]:  # swap
        ra, rb = rb, ra

    return opcode, ra, rb, func, x, rd


def decode(asm):
    """
    string line to hex string
    """
    opcode, ra, rb, rc, rd, func, imm, p, offset, s, x = asmtoint(asm)
    instruction = inttohex(opcode, ra, rb, rc, rd, func, imm, p, offset, s, x)
    return instruction


def reg(neumonic: str):
    """
    given the neumonic (example: $0, $zero, $r1, $v0, etc...)
    :param neumonic:
    :return: register number
    """

    # (key: neumonic, value: registerNumber)
    registerAliasDict = {
        '$zero': 0b00000,
        '$at': 0b00001,
        '$v0': 0b00010,
        '$v1': 0b00011,
        '$a0': 0b00100,
        '$a1': 0b00101,
        '$a2': 0b00110,
        '$a3': 0b00111,
        '$t0': 0b01000,
        '$t1': 0b01001,
        '$t2': 0b01010,
        '$t3': 0b01011,
        '$t4': 0b01100,
        '$t5': 0b01101,
        '$t6': 0b01110,
        '$t7': 0b01111,
        '$s0': 0b10000,
        '$s1': 0b10001,
        '$s2': 0b10010,
        '$s3': 0b10011,
        '$s4': 0b10100,
        '$s5': 0b10101,
        '$s6': 0b11000,
        '$s7': 0b10111,
        '$t8': 0b11000,
        '$t9': 0b11001,
        '$k0': 0b11010,
        '$k1': 0b11011,
        '$gp': 0b11100,
        '$sp': 0b11101,
        '$fp': 0b11110,
        '$ra': 0b11111,
    }

    if len(neumonic) == 2:
        return int(neumonic[1:])
    else:
        if neumonic in registerAliasDict:
            return registerAliasDict.get(neumonic, 0)
