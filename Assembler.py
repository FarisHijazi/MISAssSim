# -*- coding: utf-8 -*-
"""COE403-Assembler.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ry1iqMchHlX9o7sXect9mdND02Pp9E8I
"""

from tkinter import *
import re

# from tkFileDialog import *
from tkinter import filedialog
import os.path
from argparse import ArgumentParser
import sys
from tkinter.filedialog import askopenfilename, asksaveasfilename

filename = "Untitled"
fileexists = False
symbolTable = {}
global currentLine


def asmtointsection2(args, opcode, ra, rb, imm):
    # Compare with Zero Branches (Pseudo)
    if args[0] in opcodes.get('bzero'):
        ra = reg(args[1])
        imm = 0

        if args[0] == "blez" or args[0] == "bgtz":
            imm = 1
        return ra, rb, imm
    # Pseudo-Branches
    if args[0] in {'ble': 10, 'bgt': 11, 'bleu': 13, 'bgtu': 12, }:
        ra = reg(args[1])
        imm = int(args[2]) + 1
        return ra, rb, imm
    # Ret
    # Register-immediate Branches
    if 8 <= opcode <= 13:
        ra = reg(args[1])
        imm = int(args[2])  # p15 states this should be Uimm5
    # Register-Register Branch
    elif 16 <= opcode <= 21:
        ra = reg(args[1])
        rb = reg(args[2])
        # loop or loopd or jalr
    elif opcode == 22 or opcode == 22 or opcode == 15:
        rb = reg(args[1])
        ra = reg(args[2])
    elif opcode == 14:
        ra = reg(args[1])
    return ra, rb, imm


def asmtoint3(args, opcode):
    func = opcodes.get('ls').get(args[0])[1]
    print(str(func))
    rc = 0
    rd = 0
    imm = 0
    s = 0
    # Load I-Format
    if opcode == 24:
        rb = reg(args[1])
        ra = reg(args[2])
        imm = int(args[3])
    # Store I-Format
    elif opcode == 25:
        rb = reg(args[3])
        ra = reg(args[1])
        imm = int(args[2])
    # Loadx R-Format
    elif opcode == 26:
        rb = reg(args[3])
        ra = reg(args[2])
        rd = reg(args[1])
        s = int(args[4])
    elif opcode == 27:
        rb = reg(args[2])
        ra = reg(args[1])
        rc = reg(args[4])
        s = int(args[3])
    return ra, rb, rc, rd, s, func, imm


def asmtointFPU1(args):
    rd = reg(args[1])
    ra = reg(args[2])
    opcode = 42
    p, func = fpu1_dict[args[0]]
    return opcode, ra,rd, func, p


def asmtointFPU2(args):
    rd = reg(args[1])
    ra = reg(args[2])
    rb = reg(args[3])
    opcode = 43
    p, func, swp = fpu2_dict[args[0]]

    if swp:
        ra, rb = rb, ra

    return opcode, ra, rb, rd, func, p


def asmtointFPU3(args, opcode, ra, rb, rc, rd, func, imm, p):
    rd = reg(args[1])
    ra = reg(args[2])
    rb = reg(args[3])
    rc = reg(args[4])
    opcode = 44
    p, func, swp = fpu3_dict[args[0]]

    if swp:
        rc, rb = rb, rc

    return opcode, ra, rb, rc, rd, func, imm, p


def asmtoint5(args):
    print("asmtoint5")
    rd = reg(args[1])
    ra = reg(args[2])
    rb = reg(args[3])
    rc = reg(args[4])
    opcode = 41

    x, func = sec5_dict[args[0]]

    if args[0] == "selz":  # sel , switch b and c
        temp = rb
        rb = rc
        rc = temp

    return opcode, ra, rb, rc, rd, func, x


def inttohex(opcode, ra, rb, rc, rd, func, imm, p, offset, s, x):
    if opcode == 2 or opcode == 3:
        opstr = format(opcode, '06b')
        offsetstr = format(offset, '026b')
        instruction = opstr + offsetstr
    # Section 2 (branch imm)
    elif 8 <= opcode <= 13:
        opstr = format(opcode, '06b')
        rastr = format(ra, '05b')
        immstr = format(imm, '05b')  # p15 states this should be Uimm5 is this the correct format???
        offsetstr = format(offset, '016b')
        instruction = opstr + rastr + immstr + offsetstr
    # JR instruction p15
    elif opcode == 14:
        opstr = format(opcode, '06b')
        rastr = format(ra, '05b')
        emptystr = format(0, '05b')
        offsetstr = format(offset, '016b')
        instruction = opstr + rastr + emptystr + offsetstr
    # Section2 (non imm branch)
    elif 15 <= opcode <= 23:
        opstr = format(opcode, '06b')
        rastr = format(ra, '05b')
        rbstr = format(rb, '05b')
        offsetstr = format(offset, '016b')
        instruction = opstr + rastr + rbstr + offsetstr
        # Section 3
    elif opcode == 24 or opcode == 25:
        opstr = format(opcode, '06b')
        rastr = format(ra, '05b')
        rbstr = format(rb, '05b')
        funcstr = format(func, '04b')
        immstr = format(imm, '012b')
        instruction = opstr + rastr + rbstr + funcstr + immstr
    elif opcode == 26 or opcode == 27:
        opstr = format(opcode, '06b')
        rastr = format(ra, '05b')
        rbstr = format(rb, '05b')
        funcstr = format(func, '04b')
        sstr = format(s, '02b')
        rcstr = format(rc, '05b')
        rdstr = format(rd, '05b')
        instruction = opstr + rastr + rbstr + funcstr + sstr + rcstr + rdstr
    elif opcode == 41:
        opstr = format(opcode, '06b')
        rastr = format(ra, '05b')
        rbstr = format(rb, '05b')
        funcstr = format(func, '04b')
        xstr = format(s, '02b')
        rcstr = format(rc, '05b')
        rdstr = format(rd, '05b')
        instruction = opstr + rastr + rbstr + funcstr + xstr + rcstr + rdstr
        # FPU instructions
    elif opcode == 42 or opcode == 43 or opcode == 44:
        opstr = format(opcode, '06b')
        rastr = format(ra, '05b')
        rbstr = format(rb, '05b')
        rcstr = format(rc, '05b')
        rdstr = format(rd, '05b')
        fnstr = format(func, '05b')
        pstr = format(p, '01b')
        instruction = opstr + rastr + rbstr + fnstr + pstr + rcstr + rdstr
    else:
        opstr = format(opcode, '02b')
        rbstr = format(rb, '03b')
        rastr = format(ra, '03b')
        if imm < 0:
            imm2s = ((-imm) ^ 255) + 1
            immstr = format(imm2s, '08b')
        else:
            immstr = format(imm, '08b')
        # print opstr, rtstr, rsstr, immstr
        instruction = opstr + rastr + rbstr + immstr
    return format(int(instruction, 2), '04x')


"""
layed out according to section/format (I'm not sure either)
"""
opcodes = {
    'j': {
        'j': 2,
        'jal': 3,
        'jr': 14,
        'ret': 14,
        'jalr': 15,
    },
    'b': {
        'beqi': 8,
        'bnei': 9,
        'blti': 10,
        'bgei': 11,
        'bltui': 12,
        'bgeui': 13,

        'beq': 16,
        'bne': 17,
        'blt': 18,
        'bge': 19,
        'bltu': 20,
        'bgeu': 21,

        # Compare with immediate (0 to 30) and Branch Pseudo Instructions :
        'ble': 10,
        'bgt': 11,
        'bleu': 13,
        'bgtu': 12,
        # -----------
        'loop': 22,
        'loopd': 23
    },

    'bzero': {
        # Compare with Zero and Branch Pseudo-Instructions (use immediate instructions) :
        'beqz': 8,
        'bnez': 9,
        'bltz': 10,
        'bgtz': 11,
        'bgez': 11,
        'blez': 10
    },

    'ls': {
        # All instructions below come in I-Format or R-Format
        'lb': (24, 4),
        'lh': (24, 5),
        'lw': (24, 6),
        'ld': (24, 7),

        'lbu': (24, 0),
        'lhu': (24, 1),
        'lwu': (24, 2),
        'ldu': (24, 3),

        'sb': (25, 0),
        'sh': (25, 1),
        'sw': (25, 2),
        'sd': (25, 3)
    },
    'alu': {  # ALU instructions (section 5)
        "add": 41,
        "and": 41,
        "or": 41,
        "xor": 41,
        "nadd": 41,
        "cand": 41,
        "cor": 41,
        "xnor": 41,
        "andeq": 41,
        "andne": 41,
        "andlt": 41,
        "andge": 41,
        "andltu": 41,
        "andgeu": 41,
        "oreq": 41,
        "orne": 41,
        "orlt": 41,
        "orge": 41,
        "orltu": 41,
        "orgeu": 41,
        "min": 41,
        "max": 41,
        "minu": 41,
        "maxu": 41,
        "andgt": 41,
        "andle": 41,
        "andgtu": 41,
        "andleu": 41,
        "orgt": 41,
        "orle": 41,
        "orgtu": 41,
        "orleu": 41,
        "sel": 41,
        "seln": 41,
        "selp": 41,
        "selz": 41,
        "madd": 41,
        "nmadd": 41
    },
    'fpu2': {
        "eq.s": -1,
        "eq.d": -1,
        "ne.s": -1,
        "ne.d": -1,
        "lt.s": -1,
        "lt.d": -1,
        "ge.s": -1,
        "ge.d": -1,
        "inf.s": -1,
        "inf.d": -1,
        "nan.s": -1,
        "nan.d": -1,
        "mul.s": -1,
        "mul.d": -1,
        "div.s": -1,
        "div.d": -1,
        "gt.s": -1,
        "gt.d": -1,
        "le.s": -1,
        "le.d": -1,
        "sub.s": -1,
        "sub.d": -1,
    }
}
fpu1_dict = {
    "abs.s": (0, 0),
    "abs.d": (1, 0),
    "neg.s": (0, 1),
    "neg.d": (1, 1),
    "sqrt.s": (0, 2),
    "sqrt.d": (1, 2),
    "cvts.d": (0, 4),
    "cvtd.s": (1, 4),
    "cvts.i": (0, 5),
    "cvtd.i": (1, 5),
    "cvti.s": (0, 6),
    "cvti.d": (1, 6),
    "rint.s": (0, 7),
    "rint.d": (1, 7),
}
# neumonic: (p, func, swap_ra_rb)
fpu2_dict = {
    "eq.s": (0, 0, False),
    "eq.d": (1, 0, False),
    "ne.s": (0, 1, False),
    "ne.d": (1, 1, False),
    "lt.s": (0, 2, False),
    "lt.d": (1, 2, False),
    "ge.s": (0, 3, False),
    "ge.d": (1, 3, False),
    "inf.s": (0, 4, False),
    "inf.d": (1, 4, False),
    "nan.s": (0, 5, False),
    "nan.d": (1, 5, False),
    "add.s": (0, 8, False),
    "add.d": (1, 8, False),
    "nadd.s": (0, 9, False),
    "nadd.d": (1, 9, False),
    "mul.s": (0, 10, False),
    "mul.d": (1, 10, False),
    "div.s": (0, 11, False),
    "div.d": (1, 11, False),
    "min.s": (0, 12, False),
    "min.d": (1, 12, False),
    "max.s": (0, 13, False),
    "max.d": (1, 13, False),
    "gt.s": (0, 2, True),
    "gt.d": (1, 2, True),
    "le.s": (0, 3, True),
    "le.d": (1, 3, True),
    "sub.s": (0, 9, True),
    "sub.d": (1, 9, True),
}
# neumonic: (p, func, swap_rc_rb)
fpu3_dict = {
    "add.s": (0, 8, False),
    "add.d": (1, 8, False),
    "nadd.s": (0, 9, False),
    "nadd.d": (1, 9, False),
    "madd.s": (0, 10, False),
    "madd.d": (1, 10, False),
    "nmadd.s": (0, 11, False),
    "nmadd.d": (1, 11, False),
    "min.s": (0, 12, False),
    "min.d": (1, 12, False),
    "max.s": (0, 13, False),
    "max.d": (1, 13, False),
    "andeq.s": (0, 0, False),
    "andeq.d": (1, 0, False),
    "andne.s": (0, 1, False),
    "andne.d": (1, 1, False),
    "andlt.s": (0, 2, False),
    "andlt.d": (1, 2, False),
    "andge.s": (0, 3, False),
    "andge.d": (1, 3, False),
    "oreq.s": (0, 4, False),
    "oreq.d": (1, 4, False),
    "orne.s": (0, 5, False),
    "orne.d": (1, 5, False),
    "orlt.s": (0, 6, False),
    "orlt.d": (1, 6, False),
    "orge.s": (0, 7, False),
    "orge.d": (1, 7, False),
    "andgt.s": (0, 2, True),
    "andgt.d": (1, 2, True),
    "andle.s": (0, 3, True),
    "andle.d": (1, 3, True),
    "orgt.s": (0, 6, True),
    "orgt.d": (1, 6, True),
    "orle.s": (0, 7, True),
    "orle.d": (1, 7, True),
}
# key: neumonic, value: (x, func)
sec5_dict = {
    "add": (0, 0),
    "and": (0, 2),
    "or": (0, 4),
    "xor": (0, 6),
    "nadd": (0, 1),
    "cand": (0, 3),
    "cor": (0, 5),
    "xnor": (0, 7),
    "andeq": (1, 0),
    "andne": (1, 1),
    "andlt": (1, 2),
    "andge": (1, 3),
    "andltu": (1, 4),
    "andgeu": (1, 5),
    "oreq": (1, 8),
    "orne": (1, 9),
    "orlt": (1, 10),
    "orge": (1, 11),
    "orltu": (1, 12),
    "orgeu": (1, 13),
    "min": (1, 14),
    "max": (1, 15),
    "minu": (1, 6),
    "maxu": (1, 7),
    "andgt": (1, 2),
    "andle": (1, 3),
    "andgtu": (1, 4),
    "andleu": (1, 5),
    "orgt": (1, 10),
    "orle": (1, 11),
    "orgtu": (1, 12),
    "orleu": (1, 13),
    "sel": (2, 0),
    "seln": (2, 1),
    "selp": (2, 2),
    "selz": (2, 0),
    "madd": (2, 4),
    "nmadd": (2, 5)
}
ret_dict = {
    "retadd": 0,
    "retnadd": 1,
    "retand": 2,
    "retcand": 3,
    "retor": 4,
    "retcor": 5,
    "retxor": 6,
    "retset": 7,
    "reteq": 8,
    "retne": 9,
    "retlt": 0,
    "retge": 1,
    "retltu": 2,
    "retgeu": 3,
    "retmin": 4,
    "retmax": 5,
}


def asmtointNOP(args, opcode, ra, rb, rc, rd, func, imm, p):
    # FIXME: this is a fake function
    return opcode, imm


def asmtoint(asm):
    regex = re.compile(r"[,\s()=\[|\]]+")
    asm_split = re.split(regex, asm)
    args = []
    for i in range(len(asm_split)):
        if asm_split[i] != "":
            args.append(asm_split[i])

    print("asm_split", asm_split)

    for x in asm_split:
        if re.search(r'[^\w\d.\-]', x):
            raise Exception('Invalid character encountered:', asm)

    # print args
    opcode = 0
    func = 0
    rd = 0
    ra = 0
    rb = 0
    rc = 0
    imm = 0
    p = 0
    x = 0
    s = 0
    offset = 0

    # Checking if the opcode is of type FPU1
    if args[0] in fpu1_dict:
        if len(args) != 3:
            raise Exception('Incorrect Number of arguments')
        opcode, ra, rd, func, p = asmtointFPU1(args)
    # Checking if FPU2
    elif args[0] in opcodes.get('fpu2'):
        if len(args) != 4:
            raise Exception('Incorrect Number of arguments')
        opcode, ra, rb, rd, func, p = asmtointFPU2(args)
    elif args[0] in fpu3_dict:
        if len(args) != 5:
            raise Exception(
                'Incorrect Number of arguments : ' + str(len(args)))
        opcode, ra, rb, rc, rd, func, imm, p = asmtointFPU3(
            args, opcode, ra, rb, rd, func, p)
    # These instructions may have args len of 4 or 5 so they are not in previous groupings
    elif args[0] in fpu2_dict:
        if len(args) == 4:
            opcode, ra, rb, rc, rd, func, imm, p = asmtointFPU2(
                args, opcode, ra, rb, rc, rd, func, imm, p)
        elif len(args) == 5:
            opcode, ra, rb, rc, rd, func, imm, p = asmtointFPU3(
                args, opcode, ra, rb, rc, rd, func, imm, p)

    # SECTION 2 branches
    elif args[0] in opcodes.get('b'):
        if len(args) != 4:
            raise Exception('Incorrect Number of arguments : ' + str(len(args)))
        # Check if user used immediate or register version of the instruction
        if args[2][0] != "r":
            args[0] = args[0] + "i"

        opcode = opcodes.get('b').get(args[0])
        label = args[3]
        offset = symbolTable[label] - currentLine
        ra, rb, imm = asmtointsection2(args, opcode, ra, rb, imm)
    elif args[0] in opcodes.get('bzero'):
        if len(args) != 3:
            raise Exception('Incorrect Number of arguments : ' + str(len(args)))

        opcode = opcodes.get('b').get(args[0])
        label = args[2]
        offset = symbolTable[label] - currentLine
        ra, rb, imm = asmtointsection2(args, opcode, ra, rb, imm)
    # SECTION 2 j type (does not call asmtointsection2)
    elif args[0] in opcodes.get('j'):
        if args[0] == "jal" or args[0] == "j":
            label = args[1]
            offset = symbolTable[label] - currentLine
        elif args[0] == "jr":
            if len(args) == 3:
                label = args[2]
                offset = symbolTable[label] - currentLine
            elif len(args) == 2:
                offset = 0
            else:
                raise Exception(
                    'Incorrect Number of arguments : ' + str(len(args)))
            ra = int(args[1])
        elif args[0] == "jalr":
            if len(args) == 4:
                label = args[3]
                offset = symbolTable[label] - currentLine
            elif len(args) == 3:
                offset = 0
            else:
                raise Exception(
                    'Incorrect Number of arguments : ' + str(len(args)))
            ra = reg(args[2])
            rb = reg(args[1])
        elif args[0] == "ret":
            if len(args) != 1:
                raise Exception(
                    'Incorrect Number of arguments : ' + str(len(args)))
            offset = 0
            ra = 31
        opcode = opcodes.get('j').get(args[0])
    # Section 3
    elif args[0] in opcodes.get('ls'):
        opcode = opcodes.get('ls').get(args[0])[0]
        # Check if it is R-Format (has 5 arguments)
        if len(args) == 5:
            opcode = opcode + 2
        if len(args) != 5 and len(args) != 4:
            raise Exception(
                'Incorrect Number of arguments : ' + str(len(args)))
        ra, rb, rc, rd, s, func, imm = asmtoint3(args, opcode)


    # Section 4
    # Checking if it belongs to ALUI (Opcode 32 - 35)

    elif args[0] in ["add", "and", "or", "xor", "nadd", "cand", ]:
        if len(args) != 5:
            opcode, ra, rb, func, imm = asmtointALUI(args, opcode, ra, rb, rc, rd, func, imm, p)

    # Checking if it belongs to RET (Opcode 36)
    elif args[0] in ["cor", "xnor", "sub", "andc", ]:
        print(args[0])
        if (len(args) != 4) and args[0]!= "xnor" and args[0]!="cor":# XNOR is in section 5 and contains 5 arguments
             raise Exception('Incorrect Number of arguments')
        if len(args) == 4: # This line exists to not include section5 xnor
            opcode, ra, rb, func, imm = asmtointRET(args, opcode, ra, rb, rc, rd, func, imm, p)
    # Checking if it belongs to NOP (Opcode 0)         ############## REVIEW, I have done nothing with this NOP
    elif args[0] == "orc":
        if len(args) != 2:
            raise Exception('Incorrect Number of arguments')
        opcode, imm = asmtointNOP(args, opcode, ra, rb, rc, rd, func, imm, p)

    # Checking if it belongs to SHIFT (Opcode 37)
    elif args[0] in ["eq", "ne", "lt", "ge", "ltu", ]:
        if len(args) != 4:
            raise Exception('Incorrect Number of arguments')
        opcode, ra, rb, func, imm, p = asmtointSHIFT(args, opcode, ra, rb, rc, rd, func, imm, p)

    # Checking if it belongs to ALU (Opcode 40)
    elif args[0] in ["geu", "min", "max", "gt", "le", "gtu", "leu", "retadd", "retnadd", "retand", "retcand", ]:
        if len(args) != 4 and args[0]!= "min" and args[0]!="max":  # WHY does it have to be length 4 when adds and nadds has a length of 3?!!!
            raise Exception('Incorrect Number of arguments')
        opcode, ra, rb, func, x, rd = asmtointALU(args, opcode)
    # Opcode 41
    elif args[0] in opcodes.get('alu'):
        if len(args) != 5 and len(args)!=4:
            raise Exception("Incorrect Number of parameters passed")
        if len(args)==5:
            opcode, ra, rb, rc, rd, func, x = asmtoint5(args)
    else:
        print("Returning all zeroes since the instruction is not recognized")
        return 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

    # opcode 41
    # This is not elif statement because it shares instruction names with previous elif statements
    if args[0] in opcodes.get('alu'):
        if len(args) != 5 and len(args)!=4:
            raise Exception("Incorrect Number of parameters passed")
        if len(args)==5:
            opcode, ra, rb, rc, rd, func, x = asmtoint5(args)
    return opcode, ra, rb, rc, rd, func, imm, p, offset, s, x


def asmtointALUI(args, opcode, ra, rb, rc, rd, func, imm, p):
    rb = reg(args[1])
    ra = reg(args[2])
    imm = int(args[3])

    # Opcode 32
    if args[0] == "add":
        opcode = 32
        func = 0
    elif args[0] == "nadd":
        opcode = 32
        func = 1
    elif args[0] == "and":
        opcode = 32
        func = 2
    elif args[0] == "cand":
        opcode = 32
        func = 3

        # Opcode 33
    elif args[0] == "or":
        opcode = 33
        func = 4
    elif args[0] == "cor":
        opcode = 33
        func = 5
    elif args[0] == "xor":
        opcode = 33
        func = 6
    elif args[0] == "set":
        opcode = 33
        func = 7
        imm = int(args[2])


    # Opcode 34
    elif args[0] == "eq":
        opcode = 34
        func = 8
    elif args[0] == "ne":
        opcode = 34
        func = 9
    elif args[0] == "lt":
        opcode = 34
        func = 10
    elif args[0] == "ge":
        opcode = 34
        func = 11

        # Opcode 35
    elif args[0] == "ltu":
        opcode = 35
        func = 12
    elif args[0] == "geu":
        opcode = 35
        func = 13
    elif args[0] == "min":
        opcode = 35
        func = 14
    elif args[0] == "max":
        opcode = 35
        func = 15

        # Pseudo-Instructions for ALUI
    elif args[0] == "sub":  # uses add , -imm
        opcode = 32
        func = 0
        imm = - imm
    elif args[0] == "mov":  # uses or ,  imm = 0
        opcode = 33
        func = 4
        imm = 0
    elif args[0] == "neg":  # uses nadd , imm = 0
        opcode = 32
        func = 1
        imm = 0
    elif args[0] == "not":  # uses cor ,  imm = 0
        opcode = 33
        func = 5
        imm = 0

        # Compare Pseudo-Instructions for ALUI
    elif args[0] == "gt":  # uses ge  , imm = imm + 1
        opcode = 32
        func = 0
        imm = imm + 1
    elif args[0] == "le":  # uses lt  , imm = imm + 1
        opcode = 32
        func = 0
        imm = imm + 1
    elif args[0] == "gtu":  # uses geu , imm = imm + 1
        opcode = 33
        func = 4
        imm = imm + 1
    elif args[0] == "leu":  # uses ltu , imm = imm + 1
        opcode = 33
        func = 4
        imm = imm + 1

    return opcode, ra, rb, func, imm


def asmtointRET(args, opcode, ra, rb, rc, rd, func, imm, p):
    ra = reg(args[1])
    rb = reg(args[2])
    imm = int(args[3])
    opcode = 36

    func = ret_dict.get(args[0])

    if func == 7:
        imm = int(args[2])

    return opcode, ra, rb, func, imm


def asmtointSHIFT(args, opcode, ra, rb, rc, rd, func, imm, p):
    rb = reg(args[1])
    ra = reg(args[2])
    opcode = 37
    if args[0] == "shlr":
        func = 0
        imm_L = int(args[3])
        imm_R = int(args[4])
    elif args[0] == "shlr":
        func = 1
        imm_L = int(args[3])
        imm_R = int(args[4])
    elif args[0] == "salr":
        func = 2
        imm_L = int(args[3])
        imm_R = int(args[4])
    elif args[0] == "ror":  # only 3 args, imm_R is the 3rd arg
        func = 3
        imm_R = int(args[3])
    elif args[0] == "mul":  # only 3 args, imm   is the 3rd arg
        func = 8
        imm = int(args[3])
    elif args[0] == "div":  # only 3 args, imm   is the 3rd arg
        func = 12
        imm = int(args[3])
    elif args[0] == "mod":  # only 3 args, imm   is the 3rd arg
        func = 13
        imm = int(args[3])
    elif args[0] == "divu":  # only 3 args, imm   is the 3rd arg
        func = 14
        imm = int(args[3])
    elif args[0] == "modu":  # only 3 args, imm   is the 3rd arg
        func = 15
        imm = int(args[3])
        # Pseudo-Instructions for SHIFT
    elif args[0] == "shl":  # uses shlr, imm_R = 0
        func = 0
        imm_L = int(args[3])
    elif args[0] == "shr":  # uses shlr, imm_L = 0
        func = 0
        imm_R = int(args[3])
    elif args[0] == "sar":  # uses salr, imm_L = 0
        func = 2
        imm_R = int(args[3])
    elif args[0] == "rol":  # uses ror,  imm_R = 64 - imm_R
        func = 3
        imm_R = int(args[3])
    elif args[0] == "extr":  # uses salr, imm_L = 64 - imm_L - p,  imm_R = 64 - imm_L
        func = 2
        imm_L = int(args[3])
        p = int(args[4])
    elif args[0] == "extru":  # uses shlr, imm_L = 64 - imm_L - p
        func = 0
        imm_L = int(args[3])
        p = int(args[4])
    elif args[0] == "ext":  # uses salr, imm_L = 64 - imm_L,  imm_R = 64 - imm_L
        func = 2
        imm_L = int(args[3])
    elif args[0] == "extu":  # uses shlr, imm_L = 3rd arg
        func = 0
        imm_L = int(args[3])
    elif args[0] == "insz":  # uses salr, imm_L = 3rd arg
        func = 2
        imm_L = int(args[3])
        p = int(args[4])

    return opcode, ra, rb, func, imm, p


def asmtointALU(args, opcode):
    """
    Note that func and n both share the same variable func
    :param args:
    :param opcode:
    :return: (opcode, ra, rb, func, x, rd)
    """
    rd = reg(args[1])
    ra = reg(args[2])
    rb = reg(args[3])
    opcode = 40

    # (func, x, n)
    opcode40_dict = {
        "add": (0, 0),
        "nadd": (1, 0),
        "and": (2, 0),
        "cand": (3, 0),
        "or": (4, 0),
        "cor": (5, 0),
        "xor": (6, 0),
        "xnor": (7, 0),
        "eq": (8, 0),
        "ne": (9, 0),
        "lt": (10, 0),
        "ge": (11, 0),
        "ltu": (12, 0),
        "geu": (13, 0),
        "min": (14, 0),
        "max": (15, 0),
        "shl": (0, 1),
        "shr": (1, 1),
        "sar": (2, 1),
        "ror": (3, 1),
        "mul": (8, 1),
        "div": (12, 1),
        "mod": (13, 1),
        "divu": (14, 1),
        "modu": (15, 1),

        "adds": ("n", 2),  # n = 0 ~ 15
        "nadds": ("n", 2),  # n = 0 ~ 15

        "sub": (1, 0),  # uses nadd, swaps ra & rb
        "andc": (1, 0),  # uses cand, swaps ra & rb
        "orc": (1, 0),  # uses cor,  swaps ra & rb
        "gt": (1, 0),  # uses lt,   swaps ra & rb
        "le": (1, 0),  # uses ge,   swaps ra & rb
        "gtu": (1, 0),  # uses ltu,  swaps ra & rb
        "leu": (1, 0),  # uses geu,  swaps ra & rb
    }

    func, x = opcode40_dict.get(args[0])
    if func == "n":
        func = int(args[2])

    # Pseudo-Instructions for ALU
    if args[0] in ["sub", "andc", "orc", "gt", "le", "gtu", "leu"]:  # swap
        ra, rb = rb, ra

    return opcode, ra, rb, func, x, rd


def decode(asm):
    """
    string line to hex string
    """
    opcode, ra, rb, rc, rd, func, imm, p, offset, s, x = asmtoint(asm)
    instruction = inttohex(opcode, ra, rb, rc, rd, func, imm, p, offset, s, x)
    return instruction


def reg(neumonic: str):
    """
    given the neumonic (example: $0, $zero, $r1, $v0, etc...)
    :param neumonic:
    :return: register number
    """

    # (key: neumonic, value: registerNumber)
    registerAliasDict = {
        '$zero': 0b00000,
        '$at': 0b00001,
        '$v0': 0b00010,
        '$v1': 0b00011,
        '$a0': 0b00100,
        '$a1': 0b00101,
        '$a2': 0b00110,
        '$a3': 0b00111,
        '$t0': 0b01000,
        '$t1': 0b01001,
        '$t2': 0b01010,
        '$t3': 0b01011,
        '$t4': 0b01100,
        '$t5': 0b01101,
        '$t6': 0b01110,
        '$t7': 0b01111,
        '$s0': 0b10000,
        '$s1': 0b10001,
        '$s2': 0b10010,
        '$s3': 0b10011,
        '$s4': 0b10100,
        '$s5': 0b10101,
        '$s6': 0b11000,
        '$s7': 0b10111,
        '$t8': 0b11000,
        '$t9': 0b11001,
        '$k0': 0b11010,
        '$k1': 0b11011,
        '$gp': 0b11100,
        '$sp': 0b11101,
        '$fp': 0b11110,
        '$ra': 0b11111,
    }

    if len(neumonic) == 2:
        return int(neumonic[1:])
    else:
        if neumonic in registerAliasDict:
            return registerAliasDict.get(neumonic, 0)
