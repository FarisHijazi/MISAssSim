# -*- coding: utf-8 -*-
"""COE403-Assembler.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ry1iqMchHlX9o7sXect9mdND02Pp9E8I
"""

from tkinter import *
import re

#from tkFileDialog import *
from tkinter import filedialog
import os.path

import sys

filename = "Untitled"
fileexists = False
symbolTable = {}
global currentLine


def swap(a, b):
    return (b, a)

def asmtointsection2(args, opcode, ra, rb, imm):
    # Compare with Zero Branches (Pseudo)
    if(args[0] in opcodes['bzero']):
        ra = int(args[1][1:])
        imm = 0
        
        if(args[0] == "blez" or args[0]=="bgtz"):
            imm = 1
        return ra, rb, imm
    #Pseudo-Branches
    if(args[0] in {'ble': 10,'bgt': 11,'bleu': 13,'bgtu': 12,}):
        ra = int(args[1][1:])
        imm = int(args[2]) + 1
        return ra, rb, imm
    #Ret
    #Register-Immediate Branches
    if (opcode>=8 and opcode<=13):
        ra = int(args[1][1:])
        imm = int(args[2]) # p15 states this should be UImm5
    #Register-Register Branch
    elif (opcode>=16 and opcode<=21):
        ra = int(args[1][1:])
        rb = int(args[2][1:]) 
    #loop or loopd or jalr
    elif (opcode==22 or opcode==22 or  opcode==15):
        rb = int(args[1][1:])
        ra = int(args[2][1:]) 
    elif (opcode ==14):
        ra = int(args[1][1:])
    return ra, rb, imm

def asmtoint3(args, opcode):
    func = opcodes['3'][args[0]][1]
    rc = 0
    rd = 0
    imm = 0
    s = 0
    #Load I-Format
    if(opcode == 24):
        rb = int(args[1][1:])
        ra = int(args[2][1:])
        imm = args[3]
    #Store I-Format
    elif(opcode == 25):
        rb = int(args[3][1:])
        ra = int(args[1][1:])
        imm = args[2]
    #Loadx R-Format
    elif(opcode == 26):
        rb = int(args[3][1:])
        ra = int(args[2][1:])
        rd = int(args[1][1:])
        s = int(args[4])
    elif(opcode == 27):
        rb = int(args[2][1:])
        ra = int(args[1][1:])
        rc = int(args[4][1:])
        s = int(args[3])
    return ra, rb, rc, rd, s, func, imm
    



def asmtointFPU1(args, opcode, ra, rb, rc, rd, func, imm, p):
    rd = int(args[1][1:])
    ra = int(args[2][1:])
    opcode = 42
    p, func = fpu1_dict[args[0]]
    return opcode, ra, rb, rc, rd, func, imm, p


def asmtointFPU2(args, opcode, ra, rb, rc, rd, func, imm, p):
    rd = int(args[1][1:])
    ra = int(args[2][1:])
    rb = int(args[3][1:])
    opcode = 43
    p, func, swp = fpu2_dict[args[0]]

    if swp:
        ra, rb = rb, ra

    return opcode, ra, rb, rc, rd, func, imm, p


def asmtointFPU3(args, opcode, ra, rb, rc, rd, func, imm, p):
    rd = int(args[1][1:])
    ra = int(args[2][1:])
    rb = int(args[3][1:])
    rc = int(args[4][1:])
    opcode = 44
    p, func, swp = fpu3_dict[args[0]]

    if swp:
        rc, rb = rb, rc

    return opcode, ra, rb, rc, rd, func, imm, p


def asmtoint5(args, opcode, ra, rb, rc, rd, func, x):
    rd = int(args[1][1:])
    ra = int(args[2][1:])
    rb = int(args[3][1:])
    rc = int(args[4][1:])
    opcode = 41

    x, func = sec5_dict[args[0]]

    if(args[0] == "selz"):  # sel , switch b and c
        temp = rb
        rb = rc
        rc = temp

    return opcode, ra, rb, rc, rd, func, x


def inttohex(opcode, ra, rb, rc, rd, func, imm, p, offset, s, x):


    if(opcode ==2 or opcode==3):
        opstr = format(opcode, '06b')
        offsetstr = format(offset,'026b')
        instruction = opstr + offsetstr
    #Section 2 (branch imm)
    elif(opcode>=8 and opcode <=13):
        opstr = format(opcode, '06b')
        rastr = format(ra, '05b')
        immstr = format(imm,'05b') # p15 states this should be UImm5 is this the correct format???
        offsetstr = format(offset, '016b')
        instruction = opstr + rastr + immstr + offsetstr
    #JR instruction p15
    elif (opcode == 14):
        opstr = format(opcode, '06b')
        rastr = format(ra, '05b')
        emptystr = format(0,'05b') 
        offsetstr = format(offset, '016b')
        instruction = opstr + rastr + emptystr + offsetstr
    #Section2 (non imm branch)
    elif((opcode>=15 and opcode <=23)):
        opstr = format(opcode, '06b')
        rastr = format(ra, '05b')
        rbstr = format(rb,'05b') 
        offsetstr = format(offset, '016b')
        instruction = opstr + rastr + rbstr + offsetstr      
    #Section 3
    elif (opcode ==24 or opcode==25):
        opstr = format(opcode, '06b')
        rastr = format(ra, '05b')
        rbstr = format(rb,'05b') 
        funcstr = format(offset, '04b')
        immstr = format(imm,'012b')
        instruction = opstr + rastr + rbstr + funcstr + immstr    
    elif (opcode ==26 or opcode==27):
        opstr = format(opcode, '06b')
        rastr = format(ra, '05b')
        rbstr = format(rb,'05b') 
        funcstr = format(offset, '04b')
        sstr = format(s,'02b')
        rcstr = format(rc, '05b')
        rdstr = format(rd,'05b') 
        instruction = opstr + rastr + rbstr + funcstr + sstr + rcstr + rdstr          
    # FPU instructions
    elif (opcode == 42 or opcode == 43 or opcode == 44):
        opstr = format(opcode, '06b')
        rastr = format(ra, '05b')
        rbstr = format(rb, '05b')
        rcstr = format(rc, '05b')
        rdstr = format(rd, '05b')
        fnstr = format(func, '05b')
        pstr = format(p, '01b')
        instruction = opstr + rastr + rbstr + fnstr + pstr + rcstr + rdstr

    else:
        opstr = format(opcode, '02b')
        rbstr = format(rb, '03b')
        rastr = format(ra, '03b')
        if (imm < 0):
            imm2s = ((-imm) ^ 255) + 1
            immstr = format(imm2s, '08b')
        else:
            immstr = format(imm, '08b')
        # print opstr, rtstr, rsstr, immstr
        instruction = opstr + rastr + rbstr + immstr
    return format(int(instruction, 2), '04x')


"""
layed out according to section/format (I'm not sure either)
"""
opcodes = {
    'j': {
        'j': 2,
        'jal': 3,
        'jr': 14,
        'ret': 14,
        'jalr': 15,
    },
    'b': {
        'beqi': 8,
        'bnei': 9,
        'blti': 10,
        'bgei': 11,
        'bltui': 12,
        'bgeui': 13,

        'beq': 16,
        'bne': 17,
        'blt': 18,
        'bgt': 18,
        'bge': 19,
        'bltu': 20,
        'bgeu': 21,

        # Compare with Immediate (0 to 30) and Branch Pseudo Instructions :
        'ble': 10,
        'bgt': 11,
        'bleu': 13,
        'bgtu': 12,
        #-----------
        'loop': 22,
        'loopd': 23

    },
    'bzero': {
        # Compare with Zero and Branch Pseudo-Instructions (use immediate instructions) :
        'beqz': 8,
        'bnez': 9,
        'bltz': 10,
        'bgtz': 11,
        'bgez': 11,
        'blez': 10
    },
    '3': {
    # All instructions below come in I-Format or R-Format

        'lb': (24,4),
        'lh': (24,5),
        'lw': (24,6),
        'ld': (24,7),

        'lbu':(24,0),
        'lhu':(24,1),
        'lwu':(24,2),
        'ldu':(24,3),

        'sb': (25,0),
        'sh': (25,1),
        'sw': (25,2),
        'sd': (25,3)
    },
    '5': {
        "and": 41,
        "or": 41,
        "xor": 41,
        "nadd": 41,
        "cand": 41,
        "cor": 41,
        "xnor": 41,
        "andeq": 41,
        "andne": 41,
        "andlt": 41,
        "andge": 41,
        "andltu": 41,
        "andgeu": 41,
        "oreq": 41,
        "orne": 41,
        "orlt": 41,
        "orge": 41,
        "orltu": 41,
        "orgeu": 41,
        "min": 41,
        "max": 41,
        "minu": 41,
        "maxu": 41,
        "andgt": 41,
        "andle": 41,
        "andgtu": 41,
        "andleu": 41,
        "orgt": 41,
        "orle": 41,
        "orgtu": 41,
        "orleu": 41,
        "sel": 41,
        "seln": 41,
        "selp": 41,
        "selz": 41,
        "madd": 41,
        "nmadd": 41
    },
    'fpu2': {
        "eq.s": -1,
        "eq.d": -1,
        "ne.s": -1,
        "ne.d": -1,
        "lt.s": -1,
        "lt.d": -1,
        "ge.s": -1,
        "ge.d": -1,
        "inf.s": -1,
        "inf.d": -1,
        "nan.s": -1,
        "nan.d": -1,
        "mul.s": -1,
        "mul.d": -1,
        "div.s": -1,
        "div.d": -1,
        "gt.s": -1,
        "gt.d": -1,
        "le.s": -1,
        "le.d": -1,
        "sub.s": -1,
        "sub.d": -1,
    }
}
fpu1_dict = {
    "abs.s": (0, 0),
    "abs.d": (1, 0),
    "neg.s": (0, 1),
    "neg.d": (1, 1),
    "sqrt.s": (0, 2),
    "sqrt.d": (1, 2),
    "cvts.d": (0, 4),
    "cvtd.s": (1, 4),
    "cvts.i": (0, 5),
    "cvtd.i": (1, 5),
    "cvti.s": (0, 6),
    "cvti.d": (1, 6),
    "rint.s": (0, 7),
    "rint.d": (1, 7),
}
# neumonic: (p, func, swap_ra_rb)
fpu2_dict = {
    "eq.s": (0, 0, False),
    "eq.d": (1, 0, False),
    "ne.s": (0, 1, False),
    "ne.d": (1, 1, False),
    "lt.s": (0, 2, False),
    "lt.d": (1, 2, False),
    "ge.s": (0, 3, False),
    "ge.d": (1, 3, False),
    "inf.s": (0, 4, False),
    "inf.d": (1, 4, False),
    "nan.s": (0, 5, False),
    "nan.d": (1, 5, False),
    "add.s": (0, 8, False),
    "add.d": (1, 8, False),
    "nadd.s": (0, 9, False),
    "nadd.d": (1, 9, False),
    "mul.s": (0, 10, False),
    "mul.d": (1, 10, False),
    "div.s": (0, 11, False),
    "div.d": (1, 11, False),
    "min.s": (0, 12, False),
    "min.d": (1, 12, False),
    "max.s": (0, 13, False),
    "max.d": (1, 13, False),
    "gt.s": (0, 2, True),
    "gt.d": (1, 2, True),
    "le.s": (0, 3, True),
    "le.d": (1, 3, True),
    "sub.s": (0, 9, True),
    "sub.d": (1, 9, True),
}
# neumonic: (p, func, swap_rc_rb)
fpu3_dict = {
    "add.s": (0, 8, False),
    "add.d": (1, 8, False),
    "nadd.s": (0, 9, False),
    "nadd.d": (1, 9, False),
    "madd.s": (0, 10, False),
    "madd.d": (1, 10, False),
    "nmadd.s": (0, 11, False),
    "nmadd.d": (1, 11, False),
    "min.s": (0, 12, False),
    "min.d": (1, 12, False),
    "max.s": (0, 13, False),
    "max.d": (1, 13, False),
    "andeq.s": (0, 0, False),
    "andeq.d": (1, 0, False),
    "andne.s": (0, 1, False),
    "andne.d": (1, 1, False),
    "andlt.s": (0, 2, False),
    "andlt.d": (1, 2, False),
    "andge.s": (0, 3, False),
    "andge.d": (1, 3, False),
    "oreq.s": (0, 4, False),
    "oreq.d": (1, 4, False),
    "orne.s": (0, 5, False),
    "orne.d": (1, 5, False),
    "orlt.s": (0, 6, False),
    "orlt.d": (1, 6, False),
    "orge.s": (0, 7, False),
    "orge.d": (1, 7, False),
    "andgt.s": (0, 2, True),
    "andgt.d": (1, 2, True),
    "andle.s": (0, 3, True),
    "andle.d": (1, 3, True),
    "orgt.s": (0, 6, True),
    "orgt.d": (1, 6, True),
    "orle.s": (0, 7, True),
    "orle.d": (1, 7, True),
}
# key: neumonic, value: (x, func)
sec5_dict = {
    "add":  (0, 0),
    "and":  (0, 2),
    "or":  (0, 4),
    "xor":  (0, 6),
    "nadd":  (0, 1),
    "cand":  (0, 3),
    "cor":  (0, 5),
    "xnor":  (0, 7),
    "andeq":  (1, 0),
    "andne":  (1, 1),
    "andlt":  (1, 2),
    "andge":  (1, 3),
    "andltu":  (1, 4),
    "andgeu":  (1, 5),
    "oreq":  (1, 8),
    "orne":  (1, 9),
    "orlt":  (1, 0),
    "orge":  (1, 1),
    "orltu":  (1, 2),
    "orgeu":  (1, 3),
    "min":  (1, 4),
    "max":  (1, 5),
    "minu":  (1, 6),
    "maxu":  (1, 7),
    "andgt":  (1, 2),
    "andle":  (1, 3),
    "andgtu":  (1, 4),
    "andleu":  (1, 5),
    "orgt":  (1, 0),
    "orle":  (1, 1),
    "orgtu":  (1, 2),
    "orleu":  (1, 3),
    "sel":  (2, 0),
    "seln":  (2, 1),
    "selp":  (2, 2),
    "selz":  (2, 0),
    "madd":  (2, 4),
    "nmadd":  (2, 5)
}


def asmtoint(asm):
    asm_split = re.split(r" |,\s*|\(|\) |= |\[|\]", asm)
    args = []
    for i in range(len(asm_split)):
        if (asm_split[i] != ""):
            args.append(asm_split[i])

    print("asm_split", asm_split)

    for x in asm_split:
        if re.search(r'[^\w\d]', x):
            raise Exception('Invalid character encountered:', asm)

    # print args
    opcode = 0
    func = 0
    rd = 0
    ra = 0
    rb = 0
    rc = 0
    imm = 0
    p = 0
    x = 0
    s = 0
    offset = 0

    # Checking if the opcode is of type FPU1
    if args[0] in fpu1_dict:
        if(len(args) != 3):
            raise Exception(' Incorrect Number of arguments')
        opcode, ra, rb, rc, rd, func, imm, p = asmtointFPU1(
            args, opcode, ra, rb, rc, rd, func, imm, p)
    # Checking if FPU2
    elif args[0] in opcodes['fpu2']:
        if(len(args) != 4):
            raise Exception(' Incorrect Number of arguments')
        opcode, ra, rb, rc, rd, func, imm, p = asmtointFPU2(
            args, opcode, ra, rb, rc, rd, func, imm, p)
    elif args[0] in fpu3_dict:
        if(len(args) != 5):
            raise Exception(
                ' Incorrect Number of arguments : ' + str(len(args)))
        opcode, ra, rb, rc, rd, func, imm, p = asmtointFPU3(
            args, opcode, ra, rb, rc, rd, func, imm, p)
    # These instructions may have args len of 4 or 5 so they are not in previous groupings
    elif args[0] in fpu2_dict:
        if(len(args) == 4):
            opcode, ra, rb, rc, rd, func, imm, p = asmtointFPU2(
                args, opcode, ra, rb, rc, rd, func, imm, p)
        elif(len(args) == 5):
            opcode, ra, rb, rc, rd, func, imm, p = asmtointFPU3(
                args, opcode, ra, rb, rc, rd, func, imm, p)

    # SECTION 2 branches
    elif args[0] in opcodes['b']:
        if(len(args) != 4):
            raise Exception(
                ' Incorrect Number of arguments : ' + str(len(args)))
        #Check if user used immediate or register version of the instruction
        if(args[2][0]!="r"):
            args[0] = args[0] + "i"

        opcode = opcodes['b'][args[0]]
        label = args[3]
        offset = symbolTable[label] - currentLine
        ra, rb, imm = asmtointsection2(args, opcode, ra, rb, imm)
    elif args[0] in opcodes['bzero']:
        if(len(args) != 3):
            raise Exception(
                ' Incorrect Number of arguments : ' + str(len(args)))

        opcode = opcodes['b'][args[0]]
        label = args[2]
        offset = symbolTable[label] - currentLine
        ra, rb, imm = asmtointsection2(args, opcode, ra, rb, imm)

            

    # SECTION 2 j type (does not call asmtointsection2)
    elif args[0] in opcodes['j']:
        if(args[0] == "jal" or args[0] =="j"):
            label = args[1]
            offset = symbolTable[label] - currentLine
        elif(args[0] == "jr"):
            if(len(args)==3):
                label = args[2]
                offset = symbolTable[label] - currentLine
            elif(len(args)==2):
                offset = 0
            else:
                raise Exception(
                    ' Incorrect Number of arguments : ' + str(len(args)))   
            ra = int(args[1])                 
        elif(args[0] == "jalr"):
            if(len(args)==4):
                label = args[3]
                offset = symbolTable[label] - currentLine
            elif(len(args)==3):
                offset = 0
            else:
                raise Exception(
                    ' Incorrect Number of arguments : ' + str(len(args)))     
            ra = int(args[2][1:])
            rb = int(args[1][1:])
        elif(args[0]=="ret"):
            if(len(args)!=1):
                raise Exception(
                    ' Incorrect Number of arguments : ' + str(len(args)))
            offset = 0
            ra = 31
        opcode = opcodes['j'][args[0]]
    # Section 3
    elif args[0] in opcodes['3']:
        opcode = opcodes['3'][args[0]][0]
        # Check if it is R-Format (has 5 arguments)
        if(len(args)==5):
            opcode = opcode + 2
        if(len(args)!=5 and len(args)!=4):
            raise Exception(
                ' Incorrect Number of arguments : ' + str(len(args)))
        ra, rb, rc, rd, s, func, imm = asmtoint3(args, opcode)

    # Section 4

       # section5
    elif args[0] in opcodes['5']:
        if(len(args) != 5):
            raise Exception("Incorrect Number of parameters passed")
        opcode, ra, rb, rc, rd, func, x = asmtoint5(
            args, opcode, ra, rb, rc, rd, func, x)

    else:
        return 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    return opcode, ra, rb, rc, rd, func, imm, p, offset, s, x


def decode(asm):
    """
    string line to hex string
    """
    opcode, ra, rb, rc, rd, func, imm, p, offset, s, x = asmtoint(asm)
    instruction = inttohex(opcode, ra, rb, rc, rd, func, imm, p, offset, s, x)
    return instruction


def openFile():
    global filename
    openfilename = askopenfilename()
    if openfilename is not None:
        filename = openfilename
        asmfile = open(filename, "r")
        asmfile.seek(0)
        asmdata = asmfile.read()
        textArea.delete("1.0", "end - 1c")
        textArea.insert("1.0", asmdata)
        asmfile.close()
        filemenu.entryconfig(filemenu.index("Save"), state=NORMAL)
        frame.title("muCPU Assembler [" + filename + "]")
        frame.focus()


def saveFile():
    global filename
    asmdata = textArea.get("1.0", "end - 1c")
    asmfile = open(filename, "w")
    asmfile.seek(0)
    asmfile.truncate()
    asmfile.write(asmdata)
    asmfile.close()


def saveFileAs():
    global filename
    global fileexists
    saveasfilename = asksaveasfilename()
    if saveasfilename is not None:
        filename = saveasfilename
        fileexists = True
        asmdata = textArea.get("1.0", "end - 1c")
        asmfile = open(filename, "w")
        asmfile.seek(0)
        asmfile.truncate()
        asmfile.write(asmdata)
        asmfile.close()
        filemenu.entryconfig(filemenu.index("Save"), state=NORMAL)
        frame.title("muCPU Assembler [" + filename + "]")
        frame.focus()


def exitApp():
    frame.destroy()
    sys.exit()


def reg(neumonic: str):
    """
    given the neumonic (example: $0, $zero, $r1, $v0, etc...)
    :param neumonic:
    :return: register number
    """

    # (key: neumonic, value: registerNumber)
    registerAliasDict = {
        '$zero': 0b00000,
        '$at': 0b00001,
        '$v0': 0b00010,
        '$v1': 0b00011,
        '$a0': 0b00100,
        '$a1': 0b00101,
        '$a2': 0b00110,
        '$a3': 0b00111,
        '$t0': 0b01000,
        '$t1': 0b01001,
        '$t2': 0b01010,
        '$t3': 0b01011,
        '$t4': 0b01100,
        '$t5': 0b01101,
        '$t6': 0b01110,
        '$t7': 0b01111,
        '$s0': 0b10000,
        '$s1': 0b10001,
        '$s2': 0b10010,
        '$s3': 0b10011,
        '$s4': 0b10100,
        '$s5': 0b10101,
        '$s6': 0b11000,
        '$s7': 0b10111,
        '$t8': 0b11000,
        '$t9': 0b11001,
        '$k0': 0b11010,
        '$k1': 0b11011,
        '$gp': 0b11100,
        '$sp': 0b11101,
        '$fp': 0b11110,
        '$ra': 0b11111,
    }

    if len(neumonic) == 2:
        return int(neumonic[1:])
    else:
        if neumonic in registerAliasDict:
            return registerAliasDict.get(neumonic, 0)


def compileASM():
    global filename
    cpu_out = ""
    asm_in = textArea.get("1.0", END)
    asmlines = re.split("\n", asm_in)
    for i in range(len(asmlines)):
        asmlines[i] = asmlines[i].split('//')[0].strip()  # discard comments
        currentLine = i
        if asmlines[i] == "":
            # instruction
            continue

        if asmlines[i][0] == '.':  # directive
            # todo:
            continue
        elif asmlines[i][0] == "@":  # label
            if asmlines[i] in symbolTable:
                raise Exception('Duplicate symbol "' +
                                asmlines[i] + '" at line: ' + str(i))
            symbolTable[asmlines[i]] = i
        else:  # instruction
            cpu_out += str(i) + " => x\"" + decode(asmlines[i]) + "\",\n"
    # print cpu_out
    name, ext = os.path.splitext(filename)
    hexfilename = name + ".hex"
    hexfile = open(hexfilename, "w")
    hexfile.seek(0)
    hexfile.truncate()
    hexfile.write(cpu_out)
    print(cpu_out)
    hexfile.close()

# Assembler Main code


Tk().withdraw()
frame = Toplevel()

scrollbar = Scrollbar(frame)
scrollbar.pack(side=RIGHT, fill=Y)
frame.title("muCPU Assembler [" + filename + "]")
textArea = Text(frame, height=30, width=100, padx=3,
                pady=3, yscrollcommand=scrollbar.set)
textArea.pack(side=RIGHT)
scrollbar.config(command=textArea.yview)

menubar = Menu(frame)
filemenu = Menu(menubar, tearoff=0)
filemenu.add_command(label="Open", command=openFile)
filemenu.add_command(label="Save", command=saveFile, state=DISABLED)
filemenu.add_command(label="Save as...", command=saveFileAs)
filemenu.add_command(label="Exit", command=exitApp)
menubar.add_cascade(label="File", menu=filemenu)
runmenu = Menu(menubar, tearoff=0)
runmenu.add_command(label="Compile", command=compileASM)
menubar.add_cascade(label="Run", menu=runmenu)
frame.config(menu=menubar)

frame.minsize(750, 450)
frame.maxsize(750, 450)
frame.mainloop()
